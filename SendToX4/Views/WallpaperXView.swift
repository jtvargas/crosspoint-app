import PhotosUI
import StoreKit
import SwiftData
import SwiftUI

// MARK: - WallpaperXView

/// WallpaperX — convert images to BMP format for the X4 e-reader.
///
/// Layout:
/// - **iOS**: Preview fills the screen. Quick controls (rotation) live in the
///   `tabViewBottomAccessory` (set in MainView). Full settings open via a system
///   `.sheet()` with presentation detents — smooth 120fps, no custom gestures.
/// - **macOS**: Inline scroll layout with settings below the preview.
struct WallpaperXView: View {
    @Environment(\.modelContext) private var modelContext
    @Environment(\.requestReview) private var requestReview
    @Bindable var wallpaperVM: WallpaperViewModel
    var deviceVM: DeviceViewModel
    var settings: DeviceSettings
    var toast: ToastManager

    @AppStorage("pinchToZoomEnabled") private var pinchToZoomEnabled = false
    @State private var showDevicePopover = false
    @State private var showAppSettings = false
    @State private var showAbout = false

    // MARK: - Zoom & Pan Gesture State (GPU-composited, 120fps)
    //
    // All zoom/pan visual feedback runs via `.scaleEffect(_, anchor: .center)`
    // combined with `.offset()` — Metal-composited transforms at 120fps with
    // zero CPU cost. The offset is continuously adjusted during the pinch so
    // the content stays pinned under the user's fingers (Apple Photos style).
    //
    // The image processing pipeline (`WallpaperImageProcessor`) is only
    // invoked ONCE when a gesture ends.

    /// Accumulated screen-space scale across all completed gestures.
    @State private var committedScale: CGFloat = 1.0

    /// Accumulated screen-space offset across all completed gestures.
    @State private var committedOffset: CGSize = .zero

    /// Transient magnification delta during the current pinch gesture.
    @State private var gestureScale: CGFloat = 1.0

    /// Transient translation delta during the current drag gesture.
    @State private var gestureOffset: CGSize = .zero

    /// The rendered size of the preview image (needed for anchor→offset math).
    @State private var previewSize: CGSize = .zero

    /// Offset generated by pinching at an off-center point (keeps content
    /// pinned under fingers). Computed every frame during the magnify gesture.
    @State private var pinchOffset: CGSize = .zero

    /// Controls the auto-fading "Pinch to zoom" hint pill visibility.
    @State private var showZoomHintPill = false

    /// Task handle for the auto-fade timer so it can be cancelled.
    @State private var zoomHintTask: Task<Void, Never>?

    var body: some View {
        NavigationStack {
            #if os(iOS)
            iOSLayout
            #else
            macOSLayout
            #endif
        }
        .onChange(of: wallpaperVM.shouldRequestReview) { _, shouldPrompt in
            if shouldPrompt {
                wallpaperVM.shouldRequestReview = false
                ReviewPromptManager.recordPromptShown()
                requestReview()
            }
        }
    }

    // MARK: - iOS Layout

    #if os(iOS)
    private var iOSLayout: some View {
        VStack(spacing: 0) {
            previewArea
                .frame(maxWidth: .infinity, maxHeight: .infinity)
            statusBar
        }
        .navigationTitle(loc(.tabWallpaperX))
        .toolbar { wallpaperToolbar }
        .fileImporter(
            isPresented: $wallpaperVM.showFileImporter,
            allowedContentTypes: [.image],
            allowsMultipleSelection: false
        ) { handleFileImport($0) }
        .sheet(isPresented: $wallpaperVM.showShareSheet) {
            if let data = wallpaperVM.lastBMPData,
               let filename = wallpaperVM.lastBMPFilename {
                WallpaperShareSheetView(bmpData: data, filename: filename)
            }
        }
        .sheet(isPresented: $showAppSettings) {
            SettingsSheet(deviceVM: deviceVM, settings: settings, toast: toast)
        }
        .sheet(isPresented: $showAbout) {
            AboutAppView()
        }
    }
    #endif

    // MARK: - macOS Layout

    #if os(macOS)
    private var macOSLayout: some View {
        ScrollView {
            VStack(spacing: 20) {
                devicePreviewCard
                imageSourceButtons

                if wallpaperVM.sourceImage != nil {
                    settingsControls
                        .padding(20)
                        .glassEffect(.regular, in: .rect(cornerRadius: 12))
                }

                Spacer(minLength: 40)
            }
            .padding(.horizontal)
            .padding(.top, 8)
        }
        .navigationTitle(loc(.tabWallpaperX))
        .settingsToolbar(deviceVM: deviceVM, settings: settings, toast: toast)
        .toolbar { toolbarActions }
        .fileImporter(
            isPresented: $wallpaperVM.showFileImporter,
            allowedContentTypes: [.image],
            allowsMultipleSelection: false
        ) { handleFileImport($0) }
        .sheet(isPresented: $wallpaperVM.showShareSheet) {
            if let data = wallpaperVM.lastBMPData,
               let filename = wallpaperVM.lastBMPFilename {
                WallpaperShareSheetView(bmpData: data, filename: filename)
            }
        }
    }
    #endif

    // MARK: - Preview Area (iOS)

    private var previewArea: some View {
        VStack(spacing: 12) {
            Spacer(minLength: 4)
            devicePreviewCard
            imageSourceButtons
                .padding(.horizontal)
            Spacer(minLength: 4)
        }
    }

    // MARK: - Device Preview Card

    private var devicePreviewCard: some View {
        VStack(spacing: 6) {
            ZStack {
                if let preview = wallpaperVM.processedPreview {
                    Image(decorative: preview, scale: 1.0)
                        .resizable()
                        .interpolation(.high)
                        .aspectRatio(
                            wallpaperVM.device.aspectRatio,
                            contentMode: .fit
                        )
                        // GPU-composited transforms — 120fps, zero CPU work.
                        // scaleEffect with anchor zooms FROM the pinch point.
                        .scaleEffect(currentScale, anchor: .center)
                        .offset(currentOffset)
                        .onGeometryChange(for: CGSize.self) { proxy in
                            proxy.size
                        } action: { newSize in
                            previewSize = newSize
                        }
                } else {
                    Rectangle()
                        .fill(.quaternary)
                        .aspectRatio(
                            wallpaperVM.device.aspectRatio,
                            contentMode: .fit
                        )
                        .overlay {
                            VStack(spacing: 12) {
                                Image(systemName: "photo.artframe")
                                    .font(.system(size: 36))
                                    .foregroundStyle(.tertiary)
                                Text(loc(.selectAnImage))
                                    .font(.subheadline)
                                    .foregroundStyle(.tertiary)
                            }
                        }
                }

                // Gesture layer — transparent overlay so gestures don't
                // interfere with the image rendering layer.
                // Only attached when the experimental pinch-to-zoom toggle is on.
                if pinchToZoomEnabled {
                    Color.clear
                        .contentShape(.rect)
                        .gesture(zoomPanGesture)
                        .onTapGesture(count: 2) {
                            resetZoomPan(animated: true)
                        }
                }

                // Zoom level indicator (top-right, shown when zoomed or during pinch)
                if pinchToZoomEnabled && wallpaperVM.sourceImage != nil && currentScale > 1.01 {
                    VStack {
                        HStack {
                            Spacer()
                            Text(zoomLabel)
                                .font(.caption2.weight(.semibold).monospacedDigit())
                                .padding(.horizontal, 8)
                                .padding(.vertical, 4)
                                .background(.ultraThinMaterial, in: Capsule())
                        }
                        .padding(8)
                        Spacer()
                    }
                    .allowsHitTesting(false)
                }

                // "Pinch to zoom" hint pill (bottom-right, auto-fades)
                if pinchToZoomEnabled && showZoomHintPill {
                    VStack {
                        Spacer()
                        HStack {
                            Spacer()
                            HStack(spacing: 5) {
                                Image(systemName: "magnifyingglass.circle")
                                    .font(.caption2)
                                Text(loc(.pinchToZoom))
                                    .font(.caption2.weight(.medium))
                            }
                            .padding(.horizontal, 10)
                            .padding(.vertical, 5)
                            .background(.ultraThinMaterial, in: Capsule())
                        }
                        .padding(8)
                    }
                    .allowsHitTesting(false)
                    .transition(.opacity)
                }
            }
            .clipped()
            .clipShape(.rect(cornerRadius: 10))
            .overlay {
                RoundedRectangle(cornerRadius: 10)
                    .strokeBorder(.tertiary.opacity(0.5), lineWidth: 0.5)
            }
            .shadow(color: .black.opacity(0.15), radius: 8, y: 4)
            .padding(.horizontal)
            .onChange(of: wallpaperVM.sourceImage != nil) { _, hasImage in
                if hasImage && pinchToZoomEnabled {
                    scheduleZoomHint()
                } else if !hasImage {
                    dismissZoomHint()
                    resetZoomPan(animated: false)
                }
            }
            .onChange(of: pinchToZoomEnabled) { _, enabled in
                if !enabled {
                    dismissZoomHint()
                    resetZoomPan(animated: true)
                }
            }
            .onChange(of: currentScale) { _, newScale in
                if newScale > 1.0 {
                    dismissZoomHint()
                }
            }

            HStack(spacing: 4) {
                Image(systemName: "display")
                    .font(.caption2)
                Text(wallpaperVM.device.name)
                    .font(.caption2.weight(.medium))
                Text(
                    "\(Int(wallpaperVM.device.resolution.width))\u{00D7}\(Int(wallpaperVM.device.resolution.height))"
                )
                .font(.caption2.monospacedDigit())

                if currentScale > 1.01 {
                    Text("\u{2022}")
                        .foregroundStyle(AppColor.accent)
                    Text(loc(.zoomActive))
                        .font(.caption2)
                        .foregroundStyle(AppColor.accent)
                }
            }
            .foregroundStyle(.secondary)
        }
    }

    // MARK: - Zoom Hint Pill Helpers

    /// Show the hint pill and schedule it to auto-dismiss after 3 seconds.
    private func scheduleZoomHint() {
        zoomHintTask?.cancel()
        withAnimation(.easeIn(duration: 0.3)) {
            showZoomHintPill = true
        }
        zoomHintTask = Task {
            try? await Task.sleep(for: .seconds(3))
            guard !Task.isCancelled else { return }
            dismissZoomHint()
        }
    }

    /// Immediately hide the hint pill.
    private func dismissZoomHint() {
        zoomHintTask?.cancel()
        zoomHintTask = nil
        if showZoomHintPill {
            withAnimation(.easeOut(duration: 0.3)) {
                showZoomHintPill = false
            }
        }
    }

    // MARK: - Zoom/Pan: Computed Properties

    /// Live scale = committed * in-flight gesture delta, clamped to 1…maxZoom.
    private var currentScale: CGFloat {
        min(max(committedScale * gestureScale, 1.0), WallpaperSettings.maxZoom)
    }

    /// Live offset = committed + drag delta + pinch-anchor compensation.
    private var currentOffset: CGSize {
        CGSize(
            width: committedOffset.width + gestureOffset.width + pinchOffset.width,
            height: committedOffset.height + gestureOffset.height + pinchOffset.height
        )
    }

    /// Formatted zoom label reflecting the live gesture state (e.g. "2.0x").
    private var zoomLabel: String {
        String(format: "%.1fx", currentScale)
    }

    // MARK: - Zoom/Pan: Gesture (GPU-composited, 120fps)

    /// Combined pinch-to-zoom and drag-to-pan gesture (Apple Photos style).
    ///
    /// **During the gesture** only `@State` variables change, driving
    /// `.scaleEffect(_, anchor: .center)` / `.offset()` which are
    /// Metal-composited — zero CPU cost, native 120fps on ProMotion.
    /// The offset is adjusted every frame so the content stays pinned
    /// under the user's fingers at the pinch focal point.
    ///
    /// **On gesture end** the screen-space state is committed and converted to
    /// normalised `WallpaperSettings` values, triggering exactly ONE full
    /// `WallpaperImageProcessor.process()` call. Scale and offset settle to
    /// their clamped values via spring animation for a natural feel.
    private var zoomPanGesture: some Gesture {
        let magnify = MagnifyGesture()
            .onChanged { value in
                guard wallpaperVM.sourceImage != nil else { return }
                wallpaperVM.isGestureActive = true

                let proposed = committedScale * value.magnification

                // Rubber-band beyond limits instead of hard clamping.
                // This gives the stretchy, physical feel at the boundaries.
                let minScale: CGFloat = 1.0
                let maxScale = WallpaperSettings.maxZoom
                let dampened: CGFloat
                if proposed < minScale {
                    let excess = minScale - proposed
                    dampened = minScale - Self.rubberBand(excess, limit: 0.5)
                } else if proposed > maxScale {
                    let excess = proposed - maxScale
                    dampened = maxScale + Self.rubberBand(excess, limit: 1.0)
                } else {
                    dampened = proposed
                }
                gestureScale = dampened / committedScale

                // Compute offset so the pinch focal point stays stationary.
                // With .scaleEffect(_, anchor: .center) the image expands
                // symmetrically from the center.  To keep the point under the
                // user's fingers fixed we shift the image by how much that
                // point moved due to the scale change relative to committed.
                let anchor = value.startAnchor
                let liveScale = dampened
                let dx = (0.5 - anchor.x) * previewSize.width
                let dy = (0.5 - anchor.y) * previewSize.height
                pinchOffset = CGSize(
                    width:  dx * (liveScale - committedScale),
                    height: dy * (liveScale - committedScale)
                )
            }
            .onEnded { value in
                guard wallpaperVM.sourceImage != nil else { return }
                let proposed = committedScale * value.magnification
                let finalScale = min(max(proposed, 1.0), WallpaperSettings.maxZoom)

                // Bake all transient offsets into one combined offset.
                let newOffset = CGSize(
                    width: committedOffset.width + gestureOffset.width + pinchOffset.width,
                    height: committedOffset.height + gestureOffset.height + pinchOffset.height
                )

                // Reset transient gesture state immediately.
                gestureScale = 1.0
                gestureOffset = .zero
                pinchOffset = .zero

                // Snap back to 1x if close to identity.
                if finalScale < 1.05 {
                    withAnimation(.spring(response: 0.35, dampingFraction: 0.75)) {
                        committedScale = 1.0
                        committedOffset = .zero
                    }
                    commitToSettings()
                    return
                }

                // Animate to the clamped final state with a spring for
                // natural deceleration and bounce-back at edges.
                withAnimation(.interpolatingSpring(stiffness: 200, damping: 25)) {
                    committedScale = finalScale
                    committedOffset = clampOffset(newOffset, scale: finalScale)
                }
                commitToSettings()
            }

        let drag = DragGesture()
            .onChanged { value in
                guard wallpaperVM.sourceImage != nil,
                      committedScale * gestureScale > 1.0 else { return }
                wallpaperVM.isGestureActive = true
                gestureOffset = value.translation
            }
            .onEnded { value in
                guard wallpaperVM.sourceImage != nil else { return }
                let raw = CGSize(
                    width: committedOffset.width + value.translation.width + pinchOffset.width,
                    height: committedOffset.height + value.translation.height + pinchOffset.height
                )

                // Reset transient state immediately.
                gestureOffset = .zero
                pinchOffset = .zero

                // Spring-animate to clamped offset for bounce-back at edges.
                withAnimation(.interpolatingSpring(stiffness: 200, damping: 25)) {
                    committedOffset = clampOffset(raw, scale: committedScale * gestureScale)
                }
                gestureScale = 1.0
                commitToSettings()
            }

        return magnify.simultaneously(with: drag)
    }

    // MARK: - Zoom/Pan: Helpers

    /// Rubber-band dampening: returns a value that asymptotically approaches
    /// `limit` as `offset` grows.  Matches UIScrollView's rubber-band formula
    /// so pinching past the min/max scale feels physical and stretchy.
    private static func rubberBand(
        _ offset: CGFloat, limit: CGFloat, coefficient: CGFloat = 0.55
    ) -> CGFloat {
        let clamped = abs(offset)
        let sign: CGFloat = offset < 0 ? -1 : 1
        guard clamped > 0, limit > 0 else { return 0 }
        return sign * (1 - (1 / (clamped * coefficient / limit + 1))) * limit
    }

    /// Clamp an offset so the image edges never leave the preview bounds.
    private func clampOffset(_ offset: CGSize, scale: CGFloat) -> CGSize {
        let maxX = max(0, (scale - 1) * previewSize.width / 2)
        let maxY = max(0, (scale - 1) * previewSize.height / 2)
        return CGSize(
            width: min(max(offset.width, -maxX), maxX),
            height: min(max(offset.height, -maxY), maxY)
        )
    }

    /// Commit screen-space zoom/pan to the processing pipeline.
    ///
    /// Converts `committedScale` / `committedOffset` to normalised
    /// `WallpaperSettings.zoomScale` / `.panOffset` and triggers one
    /// reprocessing pass.
    private func commitToSettings() {
        wallpaperVM.settings.zoomScale = committedScale

        // Convert screen-space offset → normalised −1…1 panOffset.
        let maxX = max(1, (committedScale - 1) * previewSize.width / 2)
        let maxY = max(1, (committedScale - 1) * previewSize.height / 2)
        wallpaperVM.settings.panOffset = CGSize(
            width: min(max(-committedOffset.width / maxX, -1), 1),
            height: min(max(committedOffset.height / maxY, -1), 1)
        )

        wallpaperVM.isGestureActive = false
        wallpaperVM.updatePreview()
    }

    /// Reset all zoom/pan state to defaults and trigger one reprocess.
    private func resetZoomPan(animated: Bool) {
        guard wallpaperVM.sourceImage != nil else { return }
        if animated {
            withAnimation(.spring(response: 0.35, dampingFraction: 0.75)) {
                committedScale = 1.0
                committedOffset = .zero
            }
        } else {
            committedScale = 1.0
            committedOffset = .zero
        }
        gestureScale = 1.0
        gestureOffset = .zero
        pinchOffset = .zero
        wallpaperVM.settings.zoomScale = 1.0
        wallpaperVM.settings.panOffset = .zero
        wallpaperVM.updatePreview()
    }

    // MARK: - Image Source Buttons

    private var imageSourceButtons: some View {
        HStack(spacing: 10) {
            PhotosPicker(
                selection: $wallpaperVM.selectedPhotoItem,
                matching: .images,
                photoLibrary: .shared()
            ) {
                Label(loc(.photos), systemImage: "photo.on.rectangle")
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 10)
            }
            .buttonStyle(.bordered)
            .buttonBorderShape(.roundedRectangle(radius: 10))

            Button {
                wallpaperVM.showFileImporter = true
            } label: {
                Label(loc(.tabFiles), systemImage: "folder")
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 10)
            }
            .buttonStyle(.bordered)
            .buttonBorderShape(.roundedRectangle(radius: 10))

            if wallpaperVM.sourceImage != nil {
                Button(role: .destructive) {
                    wallpaperVM.clearImage()
                } label: {
                    Image(systemName: "xmark.circle.fill")
                        .font(.title3)
                }
                .buttonStyle(.borderless)
            }
        }
    }

    // MARK: - Settings Controls (shared between macOS inline & iOS sheet)

    var settingsControls: some View {
        VStack(spacing: 20) {
            // Fit Mode
            VStack(alignment: .leading, spacing: 8) {
                Text(loc(.fit))
                    .font(.caption2)
                    .foregroundStyle(.tertiary)
                    .textCase(.uppercase)

                Picker(loc(.fitMode), selection: $wallpaperVM.settings.fitMode) {
                    ForEach(WallpaperFitMode.allCases, id: \.self) { mode in
                        Image(systemName: mode.iconName).tag(mode)
                    }
                }
                .pickerStyle(.segmented)
            }

            // Alignment
            if wallpaperVM.settings.fitMode != .stretch {
                VStack(alignment: .leading, spacing: 8) {
                    Text(loc(.alignment))
                        .font(.caption2)
                        .foregroundStyle(.tertiary)
                        .textCase(.uppercase)

                    alignmentGrid
                }
            }

            if pinchToZoomEnabled {
                Divider()

                // Zoom & Pan
                HStack {
                    Text(loc(.zoom))
                        .font(.caption2)
                        .foregroundStyle(.tertiary)
                        .textCase(.uppercase)

                    Spacer()

                    Text(zoomLabel)
                        .font(.caption2.monospacedDigit())
                        .foregroundStyle(.tertiary)

                    if wallpaperVM.settings.hasZoomOrPan || currentScale > 1.01 {
                        Button {
                            resetZoomPan(animated: false)
                        } label: {
                            Label(loc(.resetZoom), systemImage: "arrow.counterclockwise")
                                .font(.caption2)
                        }
                        .buttonStyle(.bordered)
                        .buttonBorderShape(.capsule)
                        .controlSize(.mini)
                    }
                }

                Text(loc(.zoomHint))
                    .font(.caption2)
                    .foregroundStyle(.quaternary)
                    .frame(maxWidth: .infinity, alignment: .leading)
            }

            Divider()

            // Rotation
            HStack {
                Text(loc(.rotate))
                    .font(.caption2)
                    .foregroundStyle(.tertiary)
                    .textCase(.uppercase)

                Spacer()

                rotationControls
            }

            Divider()

            // Color Depth
            VStack(alignment: .leading, spacing: 8) {
                Text(loc(.depth))
                    .font(.caption2)
                    .foregroundStyle(.tertiary)
                    .textCase(.uppercase)

                Picker(loc(.depth), selection: $wallpaperVM.settings.colorDepth) {
                    ForEach(BMPColorDepth.allCases, id: \.self) { depth in
                        Text(depth.label).tag(depth)
                    }
                }
                .pickerStyle(.segmented)

                if let warning = wallpaperVM.settings.colorDepth.warningText {
                    Label(warning, systemImage: "exclamationmark.triangle.fill")
                        .font(.caption2)
                        .foregroundStyle(AppColor.warning)
                }
            }

            Divider()

            // Effects
            Toggle(loc(.grayscale), isOn: $wallpaperVM.settings.grayscale)
                .font(.subheadline)

            Toggle(loc(.invert), isOn: $wallpaperVM.settings.invert)
                .font(.subheadline)
        }
    }

    // MARK: - Alignment Grid

    private var alignmentGrid: some View {
        HStack {
            Spacer()
            Grid(horizontalSpacing: 4, verticalSpacing: 4) {
                ForEach(0..<3) { row in
                    GridRow {
                        ForEach(0..<3) { col in
                            let alignment = alignmentFor(column: col, row: row)
                            let isSelected =
                                wallpaperVM.settings.alignment == alignment
                            Button {
                                wallpaperVM.settings.alignment = alignment
                            } label: {
                                RoundedRectangle(cornerRadius: 3)
                                    .fill(
                                        isSelected
                                            ? AnyShapeStyle(AppColor.accent)
                                            : AnyShapeStyle(.quaternary)
                                    )
                                    .frame(width: 28, height: 28)
                                    .overlay {
                                        Circle()
                                            .fill(
                                                isSelected
                                                    ? AnyShapeStyle(.white)
                                                    : AnyShapeStyle(
                                                        .secondary)
                                            )
                                            .frame(width: 6, height: 6)
                                    }
                            }
                            .buttonStyle(.plain)
                        }
                    }
                }
            }
            Spacer()
        }
    }

    private func alignmentFor(column: Int, row: Int) -> WallpaperAlignment {
        let all: [[WallpaperAlignment]] = [
            [.topLeft, .topCenter, .topRight],
            [.centerLeft, .centerCenter, .centerRight],
            [.bottomLeft, .bottomCenter, .bottomRight],
        ]
        return all[row][column]
    }

    // MARK: - Rotation Controls

    private var rotationControls: some View {
        HStack(spacing: 10) {
            Button {
                wallpaperVM.settings.rotation =
                    wallpaperVM.settings.rotation.rotatedCounterClockwise
            } label: {
                Image(systemName: "rotate.left")
            }
            .buttonStyle(.bordered)
            .buttonBorderShape(.circle)
            .controlSize(.small)

            Text("\(wallpaperVM.settings.rotation.rawValue)\u{00B0}")
                .font(.caption2.monospacedDigit())
                .foregroundStyle(.tertiary)
                .frame(minWidth: 28)

            Button {
                wallpaperVM.settings.rotation =
                    wallpaperVM.settings.rotation.rotatedClockwise
            } label: {
                Image(systemName: "rotate.right")
            }
            .buttonStyle(.bordered)
            .buttonBorderShape(.circle)
            .controlSize(.small)
        }
    }

    // MARK: - iOS Toolbar

    #if os(iOS)
    @ToolbarContentBuilder
    private var wallpaperToolbar: some ToolbarContent {
        ToolbarItemGroup(placement: .topBarLeading) {
            // Device connection status
            Button {
                showDevicePopover = true
            } label: {
                HStack(spacing: 5) {
                    Circle()
                        .fill(deviceStatusColor)
                        .frame(width: 7, height: 7)
                    Text(
                        deviceVM.isConnected
                            ? loc(.connected) : loc(.notConnected)
                    )
                    .font(.caption2)
                }
            }
            .popover(isPresented: $showDevicePopover) {
                devicePopoverContent
            }

            // Gear (app settings)
            Button {
                showAppSettings = true
            } label: {
                Image(systemName: "gearshape")
            }

            // About
            Button {
                showAbout = true
            } label: {
                Image(systemName: "info.circle")
            }
        }

        ToolbarItemGroup(placement: .topBarTrailing) {
            if wallpaperVM.lastBMPData != nil {
                Button {
                    wallpaperVM.showShareSheet = true
                } label: {
                    Label(loc(.save), systemImage: "square.and.arrow.up")
                }
            }

            Button {
                Task {
                    await wallpaperVM.convertAndSend(
                        deviceVM: deviceVM,
                        settings: settings,
                        modelContext: modelContext,
                        toast: toast
                    )
                }
            } label: {
                if wallpaperVM.isProcessing {
                    ProgressView()
                        .controlSize(.small)
                } else {
                    Label(
                        deviceVM.isConnected ? loc(.sendLabel) : loc(.tabConvert),
                        systemImage: deviceVM.isConnected
                            ? "paperplane.fill" : "photo.artframe"
                    )
                }
            }
            .disabled(
                wallpaperVM.sourceImage == nil || wallpaperVM.isProcessing
                    || deviceVM.isUploading)
        }
    }
    #endif

    // MARK: - Device Popover

    private var devicePopoverContent: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack(spacing: 8) {
                Circle()
                    .fill(deviceStatusColor)
                    .frame(width: 10, height: 10)
                Text(deviceVM.firmwareLabel)
                    .font(.subheadline.weight(.semibold))
            }

            if deviceVM.isConnected, let host = deviceVM.connectedHost {
                Label(host, systemImage: "network")
                    .font(.caption)
                    .foregroundStyle(.secondary)
            }

            Divider()

            HStack(spacing: 12) {
                Button {
                    Task { await deviceVM.refresh(settings: settings) }
                } label: {
                    Label(loc(.refresh), systemImage: "arrow.clockwise")
                        .font(.subheadline)
                }
                .buttonStyle(.bordered)
                .controlSize(.small)

                Button {
                    if deviceVM.isConnected {
                        deviceVM.disconnect()
                    } else {
                        Task { await deviceVM.search(settings: settings) }
                    }
                } label: {
                    Text(
                        deviceVM.isConnected ? loc(.disconnect) : loc(.connect)
                    )
                    .font(.subheadline)
                }
                .buttonStyle(.borderedProminent)
                .controlSize(.small)
                .tint(
                    deviceVM.isConnected ? .secondary : .accentColor)
            }

            if deviceVM.isSearching {
                HStack(spacing: 6) {
                    ProgressView()
                        .controlSize(.small)
                    Text(loc(.scanning))
                        .font(.caption)
                        .foregroundStyle(.secondary)
                }
            }
        }
        .padding()
        .frame(minWidth: 220)
    }

    // MARK: - macOS Toolbar

    #if os(macOS)
    @ToolbarContentBuilder
    private var toolbarActions: some ToolbarContent {
        ToolbarItemGroup(placement: .primaryAction) {
            if wallpaperVM.lastBMPData != nil {
                Button {
                    wallpaperVM.showShareSheet = true
                } label: {
                    Label(loc(.save), systemImage: "square.and.arrow.up")
                }
            }

            Button {
                Task {
                    await wallpaperVM.convertAndSend(
                        deviceVM: deviceVM,
                        settings: settings,
                        modelContext: modelContext,
                        toast: toast
                    )
                }
            } label: {
                if wallpaperVM.isProcessing {
                    ProgressView()
                        .controlSize(.small)
                } else {
                    Label(
                        deviceVM.isConnected ? loc(.sendLabel) : loc(.tabConvert),
                        systemImage: deviceVM.isConnected
                            ? "paperplane.fill" : "photo.artframe"
                    )
                }
            }
            .disabled(
                wallpaperVM.sourceImage == nil || wallpaperVM.isProcessing
                    || deviceVM.isUploading)
        }
    }
    #endif

    // MARK: - Status Bar (iOS)

    @ViewBuilder
    private var statusBar: some View {
        if wallpaperVM.isProcessing {
            HStack(spacing: 6) {
                ProgressView()
                    .controlSize(.mini)
                Text(wallpaperVM.statusMessage ?? loc(.processing))
                    .font(.caption)
                    .foregroundStyle(.secondary)
            }
            .padding(.horizontal, 20)
            .padding(.vertical, 6)
            .frame(maxWidth: .infinity, alignment: .leading)
        }
    }

    // MARK: - Helpers

    private var deviceStatusColor: Color {
        if deviceVM.isSearching { return AppColor.warning }
        return deviceVM.isConnected ? AppColor.success : AppColor.error
    }

    private func handleFileImport(_ result: Result<[URL], Error>) {
        switch result {
        case .success(let urls):
            if let url = urls.first {
                wallpaperVM.loadImage(from: url)
            }
        case .failure(let error):
            wallpaperVM.errorMessage = error.localizedDescription
        }
    }
}

// MARK: - WallpaperQuickControls (tab bar bottom accessory)

/// Minimal controls shown in the tab bar bottom accessory when WallpaperX is selected.
/// Contains rotation buttons, an "Advanced" button, and a global upload/batch progress indicator.
struct WallpaperQuickControls: View {
    @Bindable var wallpaperVM: WallpaperViewModel
    var deviceVM: DeviceViewModel
    var queueVM: QueueViewModel
    var rssVM: RSSFeedViewModel
    @Binding var showAdvancedSettings: Bool

    /// True when a single-file upload is actively transferring data.
    private var isUploading: Bool {
        deviceVM.isUploading
    }

    /// True when a multi-item batch operation is running (queue send or RSS batch).
    private var isBatchActive: Bool {
        queueVM.isSending || rssVM.isBatchProcessing
    }

    /// True when any send/upload operation is active.
    private var isBusy: Bool {
        isUploading || isBatchActive
    }

    /// Fractional progress for batch operations (0.0 to 1.0).
    private var batchFraction: Double {
        if let progress = queueVM.sendProgress, progress.total > 0 {
            return Double(progress.current) / Double(progress.total)
        }
        if let progress = rssVM.batchProgress, progress.total > 0 {
            return Double(progress.current) / Double(progress.total)
        }
        return 0
    }

    var body: some View {
        VStack(spacing: 0) {
            // Progress bar — thin line across full width (matches DeviceConnectionAccessory)
            if isUploading {
                ProgressView(value: deviceVM.uploadProgress, total: 1.0)
                    .tint(.accentColor)
                    .scaleEffect(y: 0.5)
            } else if isBatchActive {
                ProgressView(value: batchFraction, total: 1.0)
                    .tint(.accentColor)
                    .scaleEffect(y: 0.5)
            }

            HStack(spacing: 16) {
                // Rotate CCW
                Button {
                    wallpaperVM.settings.rotation =
                        wallpaperVM.settings.rotation.rotatedCounterClockwise
                } label: {
                    Image(systemName: "rotate.left")
                        .font(.body)
                }
                .buttonStyle(.bordered)
                .buttonBorderShape(.circle)
                .controlSize(.small)

                // Rotation label
                Text("\(wallpaperVM.settings.rotation.rawValue)\u{00B0}")
                    .font(.caption.monospacedDigit())
                    .foregroundStyle(.secondary)
                    .frame(minWidth: 28)

                // Rotate CW
                Button {
                    wallpaperVM.settings.rotation =
                        wallpaperVM.settings.rotation.rotatedClockwise
                } label: {
                    Image(systemName: "rotate.right")
                        .font(.body)
                }
                .buttonStyle(.bordered)
                .buttonBorderShape(.circle)
                .controlSize(.small)

                Spacer()

                if isUploading {
                    // Show upload progress instead of Advanced button
                    HStack(spacing: 6) {
                        ProgressView()
                            .controlSize(.small)
                        Text("\(Int(deviceVM.uploadProgress * 100))%")
                            .font(.caption.monospacedDigit())
                            .foregroundStyle(.secondary)
                    }
                } else if isBatchActive {
                    // Show batch progress (queue send or RSS batch)
                    HStack(spacing: 6) {
                        ProgressView()
                            .controlSize(.small)
                        if let progress = queueVM.sendProgress ?? rssVM.batchProgress {
                            Text("\(progress.current)/\(progress.total)")
                                .font(.caption.weight(.semibold).monospacedDigit())
                                .foregroundStyle(Color.accentColor)
                        }
                    }
                } else {
                    // Advanced settings button
                    Button {
                        showAdvancedSettings = true
                    } label: {
                        Label(loc(.advanced), systemImage: "slider.horizontal.3")
                            .font(.subheadline.weight(.medium))
                    }
                    .buttonStyle(.bordered)
                    .buttonBorderShape(.capsule)
                    .controlSize(.small)
                    .tint(.accentColor)
                }
            }
            .padding(.horizontal)
            .padding(.vertical, 8)
        }
    }
}

// MARK: - WallpaperAdvancedSheet

/// Full settings sheet presented with system detents for smooth 120fps interaction.
#if os(iOS)
struct WallpaperAdvancedSheet: View {
    @Environment(\.dismiss) private var dismiss
    @Bindable var wallpaperVM: WallpaperViewModel

    var body: some View {
        NavigationStack {
            ScrollView {
                // Reuse the shared settings controls from WallpaperXView
                WallpaperXView.settingsControlsContent(wallpaperVM: wallpaperVM)
                    .padding(.horizontal, 20)
                    .padding(.top, 8)
                    .padding(.bottom, 24)
            }
            .scrollBounceBehavior(.basedOnSize)
            .navigationTitle(loc(.settings))
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .topBarTrailing) {
                    Button(loc(.done)) {
                        dismiss()
                    }
                    .fontWeight(.semibold)
                }
            }
        }
        .presentationDetents([.fraction(0.45), .medium, .large])
        .presentationDragIndicator(.visible)
        .presentationBackgroundInteraction(.enabled(upThrough: .medium))
    }
}
#endif

// MARK: - Static settings helper (for sheet reuse)

extension WallpaperXView {
    /// Extracted settings controls as a static function so the sheet can reuse them
    /// without needing a full WallpaperXView instance.
    static func settingsControlsContent(wallpaperVM: WallpaperViewModel)
        -> some View
    {
        _SettingsControlsContent(wallpaperVM: wallpaperVM)
    }
}

/// Internal view wrapping the settings controls for reuse.
private struct _SettingsControlsContent: View {
    @Bindable var wallpaperVM: WallpaperViewModel
    @AppStorage("pinchToZoomEnabled") private var pinchToZoomEnabled = false

    var body: some View {
        VStack(spacing: 20) {
            // Fit Mode
            VStack(alignment: .leading, spacing: 8) {
                Text(loc(.fit))
                    .font(.caption2)
                    .foregroundStyle(.tertiary)
                    .textCase(.uppercase)

                Picker(loc(.fitMode), selection: $wallpaperVM.settings.fitMode) {
                    ForEach(WallpaperFitMode.allCases, id: \.self) { mode in
                        Image(systemName: mode.iconName).tag(mode)
                    }
                }
                .pickerStyle(.segmented)
            }

            // Alignment
            if wallpaperVM.settings.fitMode != .stretch {
                VStack(alignment: .leading, spacing: 8) {
                    Text(loc(.alignment))
                        .font(.caption2)
                        .foregroundStyle(.tertiary)
                        .textCase(.uppercase)

                    alignmentGrid
                }
            }

            if pinchToZoomEnabled {
                Divider()

                // Zoom & Pan
                HStack {
                    Text(loc(.zoom))
                        .font(.caption2)
                        .foregroundStyle(.tertiary)
                        .textCase(.uppercase)

                    Spacer()

                    Text(String(format: "%.1fx", wallpaperVM.settings.zoomScale))
                        .font(.caption2.monospacedDigit())
                        .foregroundStyle(.tertiary)

                    if wallpaperVM.settings.hasZoomOrPan {
                        Button {
                            wallpaperVM.settings.zoomScale = 1.0
                            wallpaperVM.settings.panOffset = .zero
                        } label: {
                            Label(loc(.resetZoom), systemImage: "arrow.counterclockwise")
                                .font(.caption2)
                        }
                        .buttonStyle(.bordered)
                        .buttonBorderShape(.capsule)
                        .controlSize(.mini)
                    }
                }

                Text(loc(.zoomHint))
                    .font(.caption2)
                    .foregroundStyle(.quaternary)
                    .frame(maxWidth: .infinity, alignment: .leading)
            }

            Divider()

            // Rotation
            HStack {
                Text(loc(.rotate))
                    .font(.caption2)
                    .foregroundStyle(.tertiary)
                    .textCase(.uppercase)

                Spacer()

                rotationControls
            }

            Divider()

            // Color Depth
            VStack(alignment: .leading, spacing: 8) {
                Text(loc(.depth))
                    .font(.caption2)
                    .foregroundStyle(.tertiary)
                    .textCase(.uppercase)

                Picker(
                    loc(.depth), selection: $wallpaperVM.settings.colorDepth
                ) {
                    ForEach(BMPColorDepth.allCases, id: \.self) { depth in
                        Text(depth.label).tag(depth)
                    }
                }
                .pickerStyle(.segmented)

                if let warning = wallpaperVM.settings.colorDepth.warningText
                {
                    Label(
                        warning,
                        systemImage: "exclamationmark.triangle.fill"
                    )
                    .font(.caption2)
                    .foregroundStyle(AppColor.warning)
                }
            }

            Divider()

            // Effects
            Toggle(loc(.grayscale), isOn: $wallpaperVM.settings.grayscale)
                .font(.subheadline)

            Toggle(loc(.invert), isOn: $wallpaperVM.settings.invert)
                .font(.subheadline)
        }
    }

    // MARK: - Alignment Grid

    private var alignmentGrid: some View {
        HStack {
            Spacer()
            Grid(horizontalSpacing: 4, verticalSpacing: 4) {
                ForEach(0..<3) { row in
                    GridRow {
                        ForEach(0..<3) { col in
                            let alignment = alignmentFor(
                                column: col, row: row)
                            let isSelected =
                                wallpaperVM.settings.alignment == alignment
                            Button {
                                wallpaperVM.settings.alignment = alignment
                            } label: {
                                RoundedRectangle(cornerRadius: 3)
                                    .fill(
                                        isSelected
                                            ? AnyShapeStyle(AppColor.accent)
                                            : AnyShapeStyle(.quaternary)
                                    )
                                    .frame(width: 28, height: 28)
                                    .overlay {
                                        Circle()
                                            .fill(
                                                isSelected
                                                    ? AnyShapeStyle(.white)
                                                    : AnyShapeStyle(
                                                        .secondary)
                                            )
                                            .frame(width: 6, height: 6)
                                    }
                            }
                            .buttonStyle(.plain)
                        }
                    }
                }
            }
            Spacer()
        }
    }

    private func alignmentFor(column: Int, row: Int) -> WallpaperAlignment {
        let all: [[WallpaperAlignment]] = [
            [.topLeft, .topCenter, .topRight],
            [.centerLeft, .centerCenter, .centerRight],
            [.bottomLeft, .bottomCenter, .bottomRight],
        ]
        return all[row][column]
    }

    // MARK: - Rotation Controls

    private var rotationControls: some View {
        HStack(spacing: 10) {
            Button {
                wallpaperVM.settings.rotation =
                    wallpaperVM.settings.rotation.rotatedCounterClockwise
            } label: {
                Image(systemName: "rotate.left")
            }
            .buttonStyle(.bordered)
            .buttonBorderShape(.circle)
            .controlSize(.small)

            Text("\(wallpaperVM.settings.rotation.rawValue)\u{00B0}")
                .font(.caption2.monospacedDigit())
                .foregroundStyle(.tertiary)
                .frame(minWidth: 28)

            Button {
                wallpaperVM.settings.rotation =
                    wallpaperVM.settings.rotation.rotatedClockwise
            } label: {
                Image(systemName: "rotate.right")
            }
            .buttonStyle(.bordered)
            .buttonBorderShape(.circle)
            .controlSize(.small)
        }
    }
}

// MARK: - Share Sheet (Platform-Adaptive)

#if canImport(UIKit)
import UIKit

struct WallpaperShareSheetView: UIViewControllerRepresentable {
    let bmpData: Data
    let filename: String

    func makeUIViewController(context: Context)
        -> UIActivityViewController
    {
        let tempURL =
            FileManager.default.temporaryDirectory
            .appendingPathComponent(filename)
        try? bmpData.write(to: tempURL)

        return UIActivityViewController(
            activityItems: [tempURL],
            applicationActivities: nil
        )
    }

    func updateUIViewController(
        _ uiViewController: UIActivityViewController,
        context: Context
    ) {}
}

#elseif canImport(AppKit)
import AppKit

struct WallpaperShareSheetView: NSViewRepresentable {
    let bmpData: Data
    let filename: String

    func makeNSView(context: Context) -> NSView {
        let view = NSView()
        DispatchQueue.main.async {
            let tempURL =
                FileManager.default.temporaryDirectory
                .appendingPathComponent(filename)
            try? bmpData.write(to: tempURL)

            let picker = NSSharingServicePicker(items: [tempURL])
            picker.show(
                relativeTo: view.bounds, of: view, preferredEdge: .minY)
        }
        return view
    }

    func updateNSView(_ nsView: NSView, context: Context) {}
}
#endif
